{"ast":null,"code":"export class Segment {\n  constructor(p1, p2) {\n    this.xi = Number.MAX_VALUE;\n    this.yi = Number.MAX_VALUE;\n    this.px1 = p1[0];\n    this.py1 = p1[1];\n    this.px2 = p2[0];\n    this.py2 = p2[1];\n    this.a = this.py2 - this.py1;\n    this.b = this.px1 - this.px2;\n    this.c = this.px2 * this.py1 - this.px1 * this.py2;\n    this._undefined = this.a === 0 && this.b === 0 && this.c === 0;\n  }\n\n  isUndefined() {\n    return this._undefined;\n  }\n\n  intersects(otherSegment) {\n    if (this.isUndefined() || otherSegment.isUndefined()) {\n      return false;\n    }\n\n    let grad1 = Number.MAX_VALUE;\n    let grad2 = Number.MAX_VALUE;\n    let int1 = 0,\n        int2 = 0;\n    const a = this.a,\n          b = this.b,\n          c = this.c;\n\n    if (Math.abs(b) > 0.00001) {\n      grad1 = -a / b;\n      int1 = -c / b;\n    }\n\n    if (Math.abs(otherSegment.b) > 0.00001) {\n      grad2 = -otherSegment.a / otherSegment.b;\n      int2 = -otherSegment.c / otherSegment.b;\n    }\n\n    if (grad1 === Number.MAX_VALUE) {\n      if (grad2 === Number.MAX_VALUE) {\n        if (-c / a !== -otherSegment.c / otherSegment.a) {\n          return false;\n        }\n\n        if (this.py1 >= Math.min(otherSegment.py1, otherSegment.py2) && this.py1 <= Math.max(otherSegment.py1, otherSegment.py2)) {\n          this.xi = this.px1;\n          this.yi = this.py1;\n          return true;\n        }\n\n        if (this.py2 >= Math.min(otherSegment.py1, otherSegment.py2) && this.py2 <= Math.max(otherSegment.py1, otherSegment.py2)) {\n          this.xi = this.px2;\n          this.yi = this.py2;\n          return true;\n        }\n\n        return false;\n      }\n\n      this.xi = this.px1;\n      this.yi = grad2 * this.xi + int2;\n\n      if ((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001 || (otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001) {\n        return false;\n      }\n\n      if (Math.abs(otherSegment.a) < 0.00001) {\n        if ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return true;\n    }\n\n    if (grad2 === Number.MAX_VALUE) {\n      this.xi = otherSegment.px1;\n      this.yi = grad1 * this.xi + int1;\n\n      if ((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001 || (this.py1 - this.yi) * (this.yi - this.py2) < -0.00001) {\n        return false;\n      }\n\n      if (Math.abs(a) < 0.00001) {\n        if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return true;\n    }\n\n    if (grad1 === grad2) {\n      if (int1 !== int2) {\n        return false;\n      }\n\n      if (this.px1 >= Math.min(otherSegment.px1, otherSegment.px2) && this.px1 <= Math.max(otherSegment.py1, otherSegment.py2)) {\n        this.xi = this.px1;\n        this.yi = this.py1;\n        return true;\n      }\n\n      if (this.px2 >= Math.min(otherSegment.px1, otherSegment.px2) && this.px2 <= Math.max(otherSegment.px1, otherSegment.px2)) {\n        this.xi = this.px2;\n        this.yi = this.py2;\n        return true;\n      }\n\n      return false;\n    }\n\n    this.xi = (int2 - int1) / (grad1 - grad2);\n    this.yi = grad1 * this.xi + int1;\n\n    if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001 || (otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\nexport function linerIntersection(l1, l2) {\n  const a1 = l1[1][1] - l1[0][1];\n  const b1 = l1[0][0] - l1[1][0];\n  const c1 = a1 * l1[0][0] + b1 * l1[0][1];\n  const a2 = l2[1][1] - l2[0][1];\n  const b2 = l2[0][0] - l2[1][0];\n  const c2 = a2 * l2[0][0] + b2 * l2[0][1];\n  const determinant = a1 * b2 - a2 * b1;\n\n  if (determinant) {\n    return [Math.round((b2 * c1 - b1 * c2) / determinant), Math.round((a1 * c2 - a2 * c1) / determinant)];\n  }\n\n  return null;\n}\nexport function centroid(points) {\n  let area = 0,\n      cx = 0,\n      cy = 0;\n\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    const next = i === points.length - 1 ? points[0] : points[i + 1];\n    area += p[0] * next[1] - next[0] * p[1];\n  }\n\n  area = area / 2;\n\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    const next = i === points.length - 1 ? points[0] : points[i + 1];\n    cx += (p[0] + next[0]) * (p[0] * next[1] - next[0] * p[1]);\n    cy += (p[1] + next[1]) * (p[0] * next[1] - next[0] * p[1]);\n  }\n\n  return [cx / (6 * area), cy / (6 * area)];\n}","map":{"version":3,"sources":["/home/hkwolfx/Documents/reactapps/labs_arts/labs-arts/FRONT/node_modules/roughjs/bin/geometry.js"],"names":["Segment","constructor","p1","p2","xi","Number","MAX_VALUE","yi","px1","py1","px2","py2","a","b","c","_undefined","isUndefined","intersects","otherSegment","grad1","grad2","int1","int2","Math","abs","min","max","linerIntersection","l1","l2","a1","b1","c1","a2","b2","c2","determinant","round","centroid","points","area","cx","cy","i","length","p","next"],"mappings":"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","sourcesContent":["export class Segment {\n    constructor(p1, p2) {\n        this.xi = Number.MAX_VALUE;\n        this.yi = Number.MAX_VALUE;\n        this.px1 = p1[0];\n        this.py1 = p1[1];\n        this.px2 = p2[0];\n        this.py2 = p2[1];\n        this.a = this.py2 - this.py1;\n        this.b = this.px1 - this.px2;\n        this.c = this.px2 * this.py1 - this.px1 * this.py2;\n        this._undefined = ((this.a === 0) && (this.b === 0) && (this.c === 0));\n    }\n    isUndefined() {\n        return this._undefined;\n    }\n    intersects(otherSegment) {\n        if (this.isUndefined() || otherSegment.isUndefined()) {\n            return false;\n        }\n        let grad1 = Number.MAX_VALUE;\n        let grad2 = Number.MAX_VALUE;\n        let int1 = 0, int2 = 0;\n        const a = this.a, b = this.b, c = this.c;\n        if (Math.abs(b) > 0.00001) {\n            grad1 = -a / b;\n            int1 = -c / b;\n        }\n        if (Math.abs(otherSegment.b) > 0.00001) {\n            grad2 = -otherSegment.a / otherSegment.b;\n            int2 = -otherSegment.c / otherSegment.b;\n        }\n        if (grad1 === Number.MAX_VALUE) {\n            if (grad2 === Number.MAX_VALUE) {\n                if ((-c / a) !== (-otherSegment.c / otherSegment.a)) {\n                    return false;\n                }\n                if ((this.py1 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                    this.xi = this.px1;\n                    this.yi = this.py1;\n                    return true;\n                }\n                if ((this.py2 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py2 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                    this.xi = this.px2;\n                    this.yi = this.py2;\n                    return true;\n                }\n                return false;\n            }\n            this.xi = this.px1;\n            this.yi = (grad2 * this.xi + int2);\n            if (((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001) || ((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001)) {\n                return false;\n            }\n            if (Math.abs(otherSegment.a) < 0.00001) {\n                if ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {\n                    return false;\n                }\n                return true;\n            }\n            return true;\n        }\n        if (grad2 === Number.MAX_VALUE) {\n            this.xi = otherSegment.px1;\n            this.yi = grad1 * this.xi + int1;\n            if (((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001) || ((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001)) {\n                return false;\n            }\n            if (Math.abs(a) < 0.00001) {\n                if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) {\n                    return false;\n                }\n                return true;\n            }\n            return true;\n        }\n        if (grad1 === grad2) {\n            if (int1 !== int2) {\n                return false;\n            }\n            if ((this.px1 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                this.xi = this.px1;\n                this.yi = this.py1;\n                return true;\n            }\n            if ((this.px2 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px2 <= Math.max(otherSegment.px1, otherSegment.px2))) {\n                this.xi = this.px2;\n                this.yi = this.py2;\n                return true;\n            }\n            return false;\n        }\n        this.xi = ((int2 - int1) / (grad1 - grad2));\n        this.yi = (grad1 * this.xi + int1);\n        if (((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) || ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001)) {\n            return false;\n        }\n        return true;\n    }\n}\nexport function linerIntersection(l1, l2) {\n    const a1 = l1[1][1] - l1[0][1];\n    const b1 = l1[0][0] - l1[1][0];\n    const c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    const a2 = l2[1][1] - l2[0][1];\n    const b2 = l2[0][0] - l2[1][0];\n    const c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    const determinant = a1 * b2 - a2 * b1;\n    if (determinant) {\n        return [\n            Math.round((b2 * c1 - b1 * c2) / determinant),\n            Math.round((a1 * c2 - a2 * c1) / determinant)\n        ];\n    }\n    return null;\n}\nexport function centroid(points) {\n    let area = 0, cx = 0, cy = 0;\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        const next = i === (points.length - 1) ? points[0] : points[i + 1];\n        area += p[0] * next[1] - next[0] * p[1];\n    }\n    area = area / 2;\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        const next = i === (points.length - 1) ? points[0] : points[i + 1];\n        cx += (p[0] + next[0]) * (p[0] * next[1] - next[0] * p[1]);\n        cy += (p[1] + next[1]) * (p[0] * next[1] - next[0] * p[1]);\n    }\n    return [cx / (6 * area), cy / (6 * area)];\n}\n"]},"metadata":{},"sourceType":"module"}