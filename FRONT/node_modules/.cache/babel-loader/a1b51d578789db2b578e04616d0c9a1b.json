{"ast":null,"code":"import { Segment } from '../geometry';\nimport { HachureIterator } from '../utils/hachure';\nexport function lineLength(line) {\n  const p1 = line[0];\n  const p2 = line[1];\n  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nexport function getIntersectingLines(line, points) {\n  const intersections = [];\n  const s1 = new Segment([line[0], line[1]], [line[2], line[3]]);\n\n  for (let i = 0; i < points.length; i++) {\n    const s2 = new Segment(points[i], points[(i + 1) % points.length]);\n\n    if (s1.intersects(s2)) {\n      intersections.push([s1.xi, s1.yi]);\n    }\n  }\n\n  return intersections;\n}\nexport function affine(x, y, cx, cy, sinAnglePrime, cosAnglePrime, R) {\n  const A = -cx * cosAnglePrime - cy * sinAnglePrime + cx;\n  const B = R * (cx * sinAnglePrime - cy * cosAnglePrime) + cy;\n  const C = cosAnglePrime;\n  const D = sinAnglePrime;\n  const E = -R * sinAnglePrime;\n  const F = R * cosAnglePrime;\n  return [A + C * x + D * y, B + E * x + F * y];\n}\nexport function hachureLinesForPolygon(points, o) {\n  const ret = [];\n\n  if (points && points.length) {\n    let left = points[0][0];\n    let right = points[0][0];\n    let top = points[0][1];\n    let bottom = points[0][1];\n\n    for (let i = 1; i < points.length; i++) {\n      left = Math.min(left, points[i][0]);\n      right = Math.max(right, points[i][0]);\n      top = Math.min(top, points[i][1]);\n      bottom = Math.max(bottom, points[i][1]);\n    }\n\n    const angle = o.hachureAngle;\n    let gap = o.hachureGap;\n\n    if (gap < 0) {\n      gap = o.strokeWidth * 4;\n    }\n\n    gap = Math.max(gap, 0.1);\n    const radPerDeg = Math.PI / 180;\n    const hachureAngle = angle % 180 * radPerDeg;\n    const cosAngle = Math.cos(hachureAngle);\n    const sinAngle = Math.sin(hachureAngle);\n    const tanAngle = Math.tan(hachureAngle);\n    const it = new HachureIterator(top - 1, bottom + 1, left - 1, right + 1, gap, sinAngle, cosAngle, tanAngle);\n    let rect;\n\n    while ((rect = it.nextLine()) != null) {\n      const lines = getIntersectingLines(rect, points);\n\n      for (let i = 0; i < lines.length; i++) {\n        if (i < lines.length - 1) {\n          const p1 = lines[i];\n          const p2 = lines[i + 1];\n          ret.push([p1, p2]);\n        }\n      }\n    }\n  }\n\n  return ret;\n}\nexport function hachureLinesForEllipse(helper, cx, cy, width, height, o) {\n  const ret = [];\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += helper.randOffset(rx * 0.05, o);\n  ry += helper.randOffset(ry * 0.05, o);\n  const angle = o.hachureAngle;\n  let gap = o.hachureGap;\n\n  if (gap <= 0) {\n    gap = o.strokeWidth * 4;\n  }\n\n  let fweight = o.fillWeight;\n\n  if (fweight < 0) {\n    fweight = o.strokeWidth / 2;\n  }\n\n  const radPerDeg = Math.PI / 180;\n  const hachureAngle = angle % 180 * radPerDeg;\n  const tanAngle = Math.tan(hachureAngle);\n  const aspectRatio = ry / rx;\n  const hyp = Math.sqrt(aspectRatio * tanAngle * aspectRatio * tanAngle + 1);\n  const sinAnglePrime = aspectRatio * tanAngle / hyp;\n  const cosAnglePrime = 1 / hyp;\n  const gapPrime = gap / (rx * ry / Math.sqrt(ry * cosAnglePrime * (ry * cosAnglePrime) + rx * sinAnglePrime * (rx * sinAnglePrime)) / rx);\n  let halfLen = Math.sqrt(rx * rx - (cx - rx + gapPrime) * (cx - rx + gapPrime));\n\n  for (let xPos = cx - rx + gapPrime; xPos < cx + rx; xPos += gapPrime) {\n    halfLen = Math.sqrt(rx * rx - (cx - xPos) * (cx - xPos));\n    const p1 = affine(xPos, cy - halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n    const p2 = affine(xPos, cy + halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n    ret.push([p1, p2]);\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["/home/hkwolfx/Documents/reactapps/labs_arts/labs-arts/FRONT/node_modules/roughjs/bin/fillers/filler-utils.js"],"names":["Segment","HachureIterator","lineLength","line","p1","p2","Math","sqrt","pow","getIntersectingLines","points","intersections","s1","i","length","s2","intersects","push","xi","yi","affine","x","y","cx","cy","sinAnglePrime","cosAnglePrime","R","A","B","C","D","E","F","hachureLinesForPolygon","o","ret","left","right","top","bottom","min","max","angle","hachureAngle","gap","hachureGap","strokeWidth","radPerDeg","PI","cosAngle","cos","sinAngle","sin","tanAngle","tan","it","rect","nextLine","lines","hachureLinesForEllipse","helper","width","height","rx","abs","ry","randOffset","fweight","fillWeight","aspectRatio","hyp","gapPrime","halfLen","xPos"],"mappings":"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","sourcesContent":["import { Segment } from '../geometry';\nimport { HachureIterator } from '../utils/hachure';\nexport function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nexport function getIntersectingLines(line, points) {\n    const intersections = [];\n    const s1 = new Segment([line[0], line[1]], [line[2], line[3]]);\n    for (let i = 0; i < points.length; i++) {\n        const s2 = new Segment(points[i], points[(i + 1) % points.length]);\n        if (s1.intersects(s2)) {\n            intersections.push([s1.xi, s1.yi]);\n        }\n    }\n    return intersections;\n}\nexport function affine(x, y, cx, cy, sinAnglePrime, cosAnglePrime, R) {\n    const A = -cx * cosAnglePrime - cy * sinAnglePrime + cx;\n    const B = R * (cx * sinAnglePrime - cy * cosAnglePrime) + cy;\n    const C = cosAnglePrime;\n    const D = sinAnglePrime;\n    const E = -R * sinAnglePrime;\n    const F = R * cosAnglePrime;\n    return [\n        A + C * x + D * y,\n        B + E * x + F * y\n    ];\n}\nexport function hachureLinesForPolygon(points, o) {\n    const ret = [];\n    if (points && points.length) {\n        let left = points[0][0];\n        let right = points[0][0];\n        let top = points[0][1];\n        let bottom = points[0][1];\n        for (let i = 1; i < points.length; i++) {\n            left = Math.min(left, points[i][0]);\n            right = Math.max(right, points[i][0]);\n            top = Math.min(top, points[i][1]);\n            bottom = Math.max(bottom, points[i][1]);\n        }\n        const angle = o.hachureAngle;\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const radPerDeg = Math.PI / 180;\n        const hachureAngle = (angle % 180) * radPerDeg;\n        const cosAngle = Math.cos(hachureAngle);\n        const sinAngle = Math.sin(hachureAngle);\n        const tanAngle = Math.tan(hachureAngle);\n        const it = new HachureIterator(top - 1, bottom + 1, left - 1, right + 1, gap, sinAngle, cosAngle, tanAngle);\n        let rect;\n        while ((rect = it.nextLine()) != null) {\n            const lines = getIntersectingLines(rect, points);\n            for (let i = 0; i < lines.length; i++) {\n                if (i < (lines.length - 1)) {\n                    const p1 = lines[i];\n                    const p2 = lines[i + 1];\n                    ret.push([p1, p2]);\n                }\n            }\n        }\n    }\n    return ret;\n}\nexport function hachureLinesForEllipse(helper, cx, cy, width, height, o) {\n    const ret = [];\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += helper.randOffset(rx * 0.05, o);\n    ry += helper.randOffset(ry * 0.05, o);\n    const angle = o.hachureAngle;\n    let gap = o.hachureGap;\n    if (gap <= 0) {\n        gap = o.strokeWidth * 4;\n    }\n    let fweight = o.fillWeight;\n    if (fweight < 0) {\n        fweight = o.strokeWidth / 2;\n    }\n    const radPerDeg = Math.PI / 180;\n    const hachureAngle = (angle % 180) * radPerDeg;\n    const tanAngle = Math.tan(hachureAngle);\n    const aspectRatio = ry / rx;\n    const hyp = Math.sqrt(aspectRatio * tanAngle * aspectRatio * tanAngle + 1);\n    const sinAnglePrime = aspectRatio * tanAngle / hyp;\n    const cosAnglePrime = 1 / hyp;\n    const gapPrime = gap / ((rx * ry / Math.sqrt((ry * cosAnglePrime) * (ry * cosAnglePrime) + (rx * sinAnglePrime) * (rx * sinAnglePrime))) / rx);\n    let halfLen = Math.sqrt((rx * rx) - (cx - rx + gapPrime) * (cx - rx + gapPrime));\n    for (let xPos = cx - rx + gapPrime; xPos < cx + rx; xPos += gapPrime) {\n        halfLen = Math.sqrt((rx * rx) - (cx - xPos) * (cx - xPos));\n        const p1 = affine(xPos, cy - halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n        const p2 = affine(xPos, cy + halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n        ret.push([p1, p2]);\n    }\n    return ret;\n}\n"]},"metadata":{},"sourceType":"module"}