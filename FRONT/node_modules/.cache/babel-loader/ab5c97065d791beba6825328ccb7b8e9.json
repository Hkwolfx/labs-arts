{"ast":null,"code":"import { Segment } from '../geometry';\nexport class HachureIterator {\n  constructor(top, bottom, left, right, gap, sinAngle, cosAngle, tanAngle) {\n    this.deltaX = 0;\n    this.hGap = 0;\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n    this.gap = gap;\n    this.sinAngle = sinAngle;\n    this.tanAngle = tanAngle;\n\n    if (Math.abs(sinAngle) < 0.0001) {\n      this.pos = left + gap;\n    } else if (Math.abs(sinAngle) > 0.9999) {\n      this.pos = top + gap;\n    } else {\n      this.deltaX = (bottom - top) * Math.abs(tanAngle);\n      this.pos = left - Math.abs(this.deltaX);\n      this.hGap = Math.abs(gap / cosAngle);\n      this.sLeft = new Segment([left, bottom], [left, top]);\n      this.sRight = new Segment([right, bottom], [right, top]);\n    }\n  }\n\n  nextLine() {\n    if (Math.abs(this.sinAngle) < 0.0001) {\n      if (this.pos < this.right) {\n        const line = [this.pos, this.top, this.pos, this.bottom];\n        this.pos += this.gap;\n        return line;\n      }\n    } else if (Math.abs(this.sinAngle) > 0.9999) {\n      if (this.pos < this.bottom) {\n        const line = [this.left, this.pos, this.right, this.pos];\n        this.pos += this.gap;\n        return line;\n      }\n    } else {\n      let xLower = this.pos - this.deltaX / 2;\n      let xUpper = this.pos + this.deltaX / 2;\n      let yLower = this.bottom;\n      let yUpper = this.top;\n\n      if (this.pos < this.right + this.deltaX) {\n        while (xLower < this.left && xUpper < this.left || xLower > this.right && xUpper > this.right) {\n          this.pos += this.hGap;\n          xLower = this.pos - this.deltaX / 2;\n          xUpper = this.pos + this.deltaX / 2;\n\n          if (this.pos > this.right + this.deltaX) {\n            return null;\n          }\n        }\n\n        const s = new Segment([xLower, yLower], [xUpper, yUpper]);\n\n        if (this.sLeft && s.intersects(this.sLeft)) {\n          xLower = s.xi;\n          yLower = s.yi;\n        }\n\n        if (this.sRight && s.intersects(this.sRight)) {\n          xUpper = s.xi;\n          yUpper = s.yi;\n        }\n\n        if (this.tanAngle > 0) {\n          xLower = this.right - (xLower - this.left);\n          xUpper = this.right - (xUpper - this.left);\n        }\n\n        const line = [xLower, yLower, xUpper, yUpper];\n        this.pos += this.hGap;\n        return line;\n      }\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"sources":["/home/hkwolfx/Documents/reactapps/labs_arts/labs-arts/FRONT/node_modules/roughjs/bin/utils/hachure.js"],"names":["Segment","HachureIterator","constructor","top","bottom","left","right","gap","sinAngle","cosAngle","tanAngle","deltaX","hGap","Math","abs","pos","sLeft","sRight","nextLine","line","xLower","xUpper","yLower","yUpper","s","intersects","xi","yi"],"mappings":"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","sourcesContent":["import { Segment } from '../geometry';\nexport class HachureIterator {\n    constructor(top, bottom, left, right, gap, sinAngle, cosAngle, tanAngle) {\n        this.deltaX = 0;\n        this.hGap = 0;\n        this.top = top;\n        this.bottom = bottom;\n        this.left = left;\n        this.right = right;\n        this.gap = gap;\n        this.sinAngle = sinAngle;\n        this.tanAngle = tanAngle;\n        if (Math.abs(sinAngle) < 0.0001) {\n            this.pos = left + gap;\n        }\n        else if (Math.abs(sinAngle) > 0.9999) {\n            this.pos = top + gap;\n        }\n        else {\n            this.deltaX = (bottom - top) * Math.abs(tanAngle);\n            this.pos = left - Math.abs(this.deltaX);\n            this.hGap = Math.abs(gap / cosAngle);\n            this.sLeft = new Segment([left, bottom], [left, top]);\n            this.sRight = new Segment([right, bottom], [right, top]);\n        }\n    }\n    nextLine() {\n        if (Math.abs(this.sinAngle) < 0.0001) {\n            if (this.pos < this.right) {\n                const line = [this.pos, this.top, this.pos, this.bottom];\n                this.pos += this.gap;\n                return line;\n            }\n        }\n        else if (Math.abs(this.sinAngle) > 0.9999) {\n            if (this.pos < this.bottom) {\n                const line = [this.left, this.pos, this.right, this.pos];\n                this.pos += this.gap;\n                return line;\n            }\n        }\n        else {\n            let xLower = this.pos - this.deltaX / 2;\n            let xUpper = this.pos + this.deltaX / 2;\n            let yLower = this.bottom;\n            let yUpper = this.top;\n            if (this.pos < (this.right + this.deltaX)) {\n                while (((xLower < this.left) && (xUpper < this.left)) || ((xLower > this.right) && (xUpper > this.right))) {\n                    this.pos += this.hGap;\n                    xLower = this.pos - this.deltaX / 2;\n                    xUpper = this.pos + this.deltaX / 2;\n                    if (this.pos > (this.right + this.deltaX)) {\n                        return null;\n                    }\n                }\n                const s = new Segment([xLower, yLower], [xUpper, yUpper]);\n                if (this.sLeft && s.intersects(this.sLeft)) {\n                    xLower = s.xi;\n                    yLower = s.yi;\n                }\n                if (this.sRight && s.intersects(this.sRight)) {\n                    xUpper = s.xi;\n                    yUpper = s.yi;\n                }\n                if (this.tanAngle > 0) {\n                    xLower = this.right - (xLower - this.left);\n                    xUpper = this.right - (xUpper - this.left);\n                }\n                const line = [xLower, yLower, xUpper, yUpper];\n                this.pos += this.hGap;\n                return line;\n            }\n        }\n        return null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}